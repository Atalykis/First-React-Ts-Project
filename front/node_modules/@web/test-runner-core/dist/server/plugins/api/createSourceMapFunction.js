"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceMapFunction = void 0;
const path_1 = require("path");
const convert_source_map_1 = __importDefault(require("convert-source-map"));
const source_map_1 = require("source-map");
const path_2 = __importDefault(require("path"));
const request_1 = require("./request");
/**
 * Fetches the source maps for a file by retreiving the original source code from the server, and
 * reading the source maps if there are any available.
 */
async function fetchSourceMap(protocol, host, port, browserUrl, filePath, userAgent) {
    // fetch the source code used by the browser, using the browser's user agent to
    // account for accurate transformation
    const { body } = await request_1.request({
        protocol,
        host,
        path: encodeURI(browserUrl),
        port: String(port),
        method: 'GET',
        headers: { 'user-agent': userAgent },
    });
    // we couldn't retreive this file, this could be because it is a generated file
    // from a server plugin which no longer exists
    if (!body) {
        return;
    }
    const sourceMap = 
    // inline source map
    convert_source_map_1.default.fromSource(body) ||
        // external source map
        convert_source_map_1.default.fromMapFileSource(body, path_1.dirname(filePath));
    return sourceMap !== null && sourceMap !== void 0 ? sourceMap : undefined;
}
function resolveRelativeTo(relativeTo, path) {
    const dir = path_1.dirname(relativeTo);
    if (path.startsWith(dir)) {
        return path;
    }
    return path_1.join(dir, path);
}
/**
 * Creates a function that can map file path, line an column based on source maps. It maintains a cache of source maps,
 * so that they are not fetched multiple times.
 * @param protocol
 * @param host
 * @param port
 */
function createSourceMapFunction(protocol, host, port) {
    const cachedSourceMaps = new Map();
    return async ({ browserUrl, filePath, line, column }, userAgent) => {
        var _a, _b;
        try {
            const cacheKey = `${filePath}${userAgent}`;
            let cached = cachedSourceMaps.get(cacheKey);
            if (cached) {
                if (cached.loadingPromise) {
                    // a request for this source map is already being done in parallel, wait for it to finish
                    await cached.loadingPromise;
                }
                if (!cached.sourceMap) {
                    // we know there is no source map for this file
                    return null;
                }
            }
            cached = {};
            cachedSourceMaps.set(cacheKey, cached);
            // get the raw source map, from cache or new
            let sourceMap;
            if (cached.sourceMap) {
                sourceMap = cached === null || cached === void 0 ? void 0 : cached.sourceMap;
            }
            else {
                // fetch source map, maintain a loading boolean for parallel calls to wait before resolving
                let resolveLoading;
                const loadingPromise = new Promise(resolve => {
                    resolveLoading = resolve;
                });
                cached.loadingPromise = loadingPromise;
                const result = await fetchSourceMap(protocol, host, port, browserUrl, filePath, userAgent);
                cached.sourceMap = result;
                resolveLoading();
                if (!result) {
                    return null;
                }
                else {
                    sourceMap = result;
                }
            }
            // if there is no line and column we're looking for just the associated file, for example
            // the test file itself has source maps. if this is a single file source map, we can return
            // that.
            if (typeof line !== 'number' || typeof column !== 'number') {
                const sources = sourceMap.getProperty('sources');
                if (sources && sources.length === 1) {
                    return {
                        filePath: resolveRelativeTo(filePath, sources[0]),
                        browserUrl,
                        line: 0,
                        column: 0,
                    };
                }
                return null;
            }
            // do the actual source mapping
            let consumer;
            if (cached === null || cached === void 0 ? void 0 : cached.consumer) {
                consumer = cached.consumer;
            }
            else {
                consumer = await new source_map_1.SourceMapConsumer(sourceMap.sourcemap);
                cachedSourceMaps.get(cacheKey).consumer = consumer;
            }
            let originalPosition = consumer.originalPositionFor({
                line: line !== null && line !== void 0 ? line : 0,
                column: column !== null && column !== void 0 ? column : 0,
                bias: source_map_1.SourceMapConsumer.GREATEST_LOWER_BOUND,
            });
            if (originalPosition.line == null) {
                originalPosition = consumer.originalPositionFor({
                    line: line !== null && line !== void 0 ? line : 0,
                    column: column !== null && column !== void 0 ? column : 0,
                    bias: source_map_1.SourceMapConsumer.LEAST_UPPER_BOUND,
                });
            }
            if (originalPosition.line == null) {
                return null;
            }
            if (!originalPosition.source) {
                return null;
            }
            const newFilePath = originalPosition.source.split('/').join(path_2.default.sep);
            return {
                filePath: resolveRelativeTo(filePath, newFilePath),
                browserUrl,
                line: (_a = originalPosition.line) !== null && _a !== void 0 ? _a : 0,
                column: (_b = originalPosition.column) !== null && _b !== void 0 ? _b : 0,
            };
        }
        catch (error) {
            console.error(error.message);
            return null;
        }
    };
}
exports.createSourceMapFunction = createSourceMapFunction;
//# sourceMappingURL=createSourceMapFunction.js.map